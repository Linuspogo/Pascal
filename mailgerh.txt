
Am 22.05.2017 um 03:07 schrieb Gerhard P.:

> Sorry that I don't have time right now to look at it, but I have questions:
>
> 1) The original Stanford Pascal had a built-in I/O bUffer, limiting
> files to 3330s. Presumably that has been fixed?

I don't know of any device dependendies of the current Pascal runtime;
if there is any, I would be happy to solve this problem. The runtime uses
QSAM I/O, and, as you know, we already did some work on this (together),
so - with my limited knowledge - I would be happy to continue this,
if there are any problems. The latest extension was to support open of PDS members
on MVS, when the name is known at runtime only - there is still some room for
improvement, but it is usable.


>
> 2) In the eighties I purchased the Borland Pascal compiler for the (IBM)
> PC. I was very disappointed to find that all subroutines had to be
> defined prior to the first reference to them, and no external subroutine
> library was permitted. Was this strictly an implementation issue, or
> does the mainframe version have similar restrictions?

this is to some degree a language issue, because the original Pascal language
was meant for teaching purposes only and had no features for external subroutines,
and in fact, for unknown subroutines, there was only the FORWARD reference, and the
subroutine or procedure was expected to be defined later in the same source file.

My implementation has

- external defintions (like most other Pascal implementations)

- library MODULEs (collections of external procedures, including static variables,
local to them - that are extensions from 2016, not present in the 1982 version);
the standard files are shared

- and: undefined functions or procedures are called anyway (warnings W184 and W186);
but there is some drawback: the compiler doesn't know if a particular parameter is
to be transferred by value or by reference, so it uses some default rules, which may
lead to runtime errors (expressions by value, variables by reference, but you may
always force a variable to be an expression by putting parantheses around it).
Undefined functions always are supposed to return an integer result. Of course,
you can always define the unknown function or procedure as external, but then
there is no type checking of the parameter (of course) due to the 
seperate compiles.


>
> 3) In view of the above, I was wondering whether there is a special
> p-code or other facility for invoking arbitrary MVS compliant
> subroutines or programs (BAL, LINK, ATTACH)?

This is a requirement for the future which I have, too;
at the moment, when I feel the need for an external function,
I write it in Pascal or I add a function to the Pascal runtime (which is written
in Assembler). But this of course is a sort of privilege of the compiler builder.

There are three ways to add new standard functions to the compiler:

a) Pascal CSPs (subroutines implemented as new CSPs, CSP aka CALL STANDARD 
PROCEDURE is a P-Code instruction with a parameter; the parameter specifies the 
action to be done, for example CSP REW = rewrite ... new CSPs have to be 
implemented by extending the PASMONN runtime)

b) a table in the compiler which translates new standard functions to calls of
so-called Pascal libraries (that is: they can be implemented in Pascal, although
the function is known to and the call to the function is generated by the compiler)

c) or by simply calling an external Pascal MODULE (and a procedure or function
defined there)

You will find many examples in the MVS oriented ZIP file on my website.

For calling ASSEMBLER subroutines from Pascal directly, some interface
macros will yet have to be provided, because the linkage conventions
differ slightly from normal OS conventions (although the save area traces
written by SYSUDUMP, for example, look very nice; there are some issues,
if ABENDs occur inside PASMONN, which should not happen in general).

I will try to improve that in the future.

Remember: the compiler runs on Windows, Linux and probably all other
platforms, that have a C-Compiler, too ... so I normally do compiler extensions,
that are not specific to MVS, on such platforms (for example the new ANYFILE
type which I added yesterday - this was developed and tested on Windows completely,
before transferring the new sources to MVS Hercules).

